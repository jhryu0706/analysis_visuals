<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Top-N Relationship Graph</title>

  <!-- Cytoscape -->
  <script src="https://unpkg.com/cytoscape@3.28.1/dist/cytoscape.min.js"></script>

  <!-- PapaParse for CSV -->
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #wrap { display: grid; grid-template-columns: 360px 1fr; height: 100vh; }
    #sidebar { border-right: 1px solid #ddd; padding: 14px; overflow: auto; }
    #cy { height: 100vh; width: 100%; }

    .legend { display: grid; gap: 8px; margin-top: 12px; }
    .legend button {
      display: flex; align-items: center; gap: 10px;
      width: 100%; padding: 10px 10px; border: 1px solid #ddd;
      background: #fff; border-radius: 10px; cursor: pointer;
      text-align: left;
    }
    .swatch { width: 14px; height: 14px; border-radius: 50%; flex: 0 0 auto; }

    .muted { opacity: 0.12; }
    .legend button.active { outline: 3px solid #000; outline-offset: 2px; }

    .hint { font-size: 12px; color: #666; line-height: 1.35; }
    .row { display: flex; align-items: center; justify-content: space-between; gap: 10px; }
    .pill { font-size: 12px; padding: 2px 8px; border: 1px solid #ddd; border-radius: 999px; color: #444; display:inline-block; }
    .controls { display: grid; gap: 10px; margin-top: 12px; }
    .control { display: grid; gap: 6px; }
    label { font-size: 12px; color: #444; }
    input[type="range"] { width: 100%; }
    input[type="text"] {
      padding: 10px; border: 1px solid #ddd; border-radius: 10px; width: 100%;
      font-size: 14px;
    }
    button.secondary {
      padding:10px 12px; border-radius:10px; border:1px solid #ddd; background:#fff; cursor:pointer;
    }
    table { border-collapse: collapse; width: 100%; }
    td { font-size: 12px; padding: 4px 0; vertical-align: top; }
    td:nth-child(1){ color:#666; width: 62px; }
    .small { font-size: 12px; color:#666; }
    .kpi { display:grid; gap:6px; margin-top:8px; }
    .kpi .pill { width: fit-content; }
  </style>
</head>

<body>
  <div id="wrap">
    <aside id="sidebar">
      <div class="row">
        <h2 style="margin:0;">Graph</h2>
        <span id="counts" class="pill">…</span>
      </div>

      <p class="hint" style="margin-top:8px;">
        Loads data from a published Google Sheet (CSV).<br/>
        Legend filter: click a category to highlight nodes of that column type.<br/>
        Search: type a value (e.g. <code>agent_11</code>) to show everything linked to it and amount totals.
      </p>

      <div class="controls">
        <div class="control">
          <label for="topN">Top N per category: <span id="topNLabel" class="pill">20</span></label>
          <input id="topN" type="range" min="5" max="50" step="1" value="20" />
          <div class="small">Higher N = denser graph.</div>
        </div>

        <div class="control">
          <label for="minEdge">Minimum edge weight: <span id="minEdgeLabel" class="pill">1</span></label>
          <input id="minEdge" type="range" min="1" max="20" step="1" value="1" />
          <div class="small">Hide weak/coincidental relationships.</div>
        </div>

        <div class="control">
          <label for="attrSearch">Find an attribute (exact match)</label>
          <input id="attrSearch" type="text" list="attrOptions" placeholder="Start typing…" />
          <datalist id="attrOptions"></datalist>
          <div class="small">Select a value to highlight its neighborhood + compute amount totals.</div>

          <div class="kpi">
            <span id="attrSummary" class="pill">No selection</span>
          </div>
        </div>
      </div>

      <div style="margin-top:12px; display:flex; gap:8px; flex-wrap: wrap;">
        <button id="resetBtn" class="secondary">Reset</button>
        <button id="fitBtn" class="secondary">Fit</button>
        <button id="reloadBtn" class="secondary">Reload</button>
        <button id="clearSearchBtn" class="secondary">Clear search</button>
      </div>

      <hr style="border:none;border-top:1px solid #eee;margin:14px 0;" />

      <h3 style="margin:0 0 6px 0; font-size:14px;">Legend</h3>
      <div class="legend" id="legend"></div>

      <hr style="border:none;border-top:1px solid #eee;margin:14px 0;" />

      <h3 style="margin:0 0 6px 0; font-size:14px;">Notes</h3>
      <table>
        <tr><td>Click</td><td>a node to center it</td></tr>
        <tr><td>Drag</td><td>nodes to rearrange</td></tr>
        <tr><td>Tip</td><td>Use Top N + Minimum edge weight to keep it fast.</td></tr>
      </table>

      <p class="hint" id="status" style="margin-top:10px;"></p>
    </aside>

    <main>
      <div id="cy"></div>
    </main>
  </div>

<script>
  // ========= CONFIG =========
  // IMPORTANT:
  // Use a PUBLISHED CSV URL (File → Share → Publish to web → CSV).
  // Example format:
  // https://docs.google.com/spreadsheets/d/e/2PACX-.../pub?output=csv
  const SHEET_CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQITmhFpwJgwfuSQFnAzUANUOB65EHTXydhXAc62IM5H-NUGhcmo-5vI9Md6-HFf2gzIYXurbqPw0tJ/pub?output=csv";

  // These must match your sheet header names exactly (case-sensitive).
  const COLUMNS = [
    "sender_name",
    "sender_agent",
    "sender_operator",
    "payee_name",
    "payee_agent",
    "payee_operator"
  ];

  // Optional numeric column used for aggregation
  const AMOUNT_COLUMN = "amount";

  const TYPE_COLORS = {
    sender_name:     "#1f77b4",
    sender_agent:    "#ff7f0e",
    sender_operator: "#2ca02c",
    payee_name:      "#d62728",
    payee_agent:     "#9467bd",
    payee_operator:  "#8c564b"
  };

  // Safety caps (keeps UI responsive for large CSVs)
  const MAX_DATALIST_OPTIONS = 5000;

  // ========= STATE =========
  let cy = null;
  let activeType = null;
  let cachedRows = null;

  // label -> array of cy node ids (same label may exist in multiple types)
  let nodeByLabel = new Map();

  // ========= HELPERS =========
  function setStatus(msg) {
    document.getElementById("status").textContent = msg || "";
  }

  function nodeId(type, value) {
    return `${type}::${String(value)}`;
  }

  function normalizeCell(v) {
    if (v === undefined || v === null) return "";
    const s = String(v).trim();
    if (!s) return "";
    const low = s.toLowerCase();
    if (low === "nan" || low === "null" || low === "undefined") return "";
    return s;
  }

  function toNumber(v) {
    const s = normalizeCell(v).replace(/,/g, "");
    const n = Number(s);
    return Number.isFinite(n) ? n : 0;
  }

  function initLegend() {
    const legend = document.getElementById("legend");
    legend.innerHTML = "";

    for (const type of COLUMNS) {
      const btn = document.createElement("button");
      btn.dataset.type = type;

      const sw = document.createElement("span");
      sw.className = "swatch";
      sw.style.background = TYPE_COLORS[type] || "#999";

      const label = document.createElement("span");
      label.textContent = type;

      btn.appendChild(sw);
      btn.appendChild(label);

      btn.addEventListener("click", () => {
        setActiveType(activeType === type ? null : type);
      });

      legend.appendChild(btn);
    }
  }

  function setActiveType(type) {
    activeType = type;

    document.querySelectorAll("#legend button").forEach(b => {
      b.classList.toggle("active", b.dataset.type === activeType);
    });

    if (!cy) return;

    // If a search selection is active, prefer it (don't fight the user's selection).
    const currentSearch = document.getElementById("attrSearch")?.value?.trim();
    if (currentSearch) {
      focusAttribute(currentSearch);
      return;
    }

    if (!activeType) {
      cy.nodes().removeClass("muted");
      cy.edges().removeClass("muted");
      return;
    }

    cy.nodes().forEach(n => {
      n.toggleClass("muted", n.data("type") !== activeType);
    });

    cy.edges().forEach(e => {
      const s = e.source(), t = e.target();
      const connected =
        (s.data("type") === activeType) || (t.data("type") === activeType);
      e.toggleClass("muted", !connected);
    });
  }

  function computeTopValues(rows, columns, topN) {
    const counts = {};
    for (const col of columns) counts[col] = new Map();

    for (const row of rows) {
      for (const col of columns) {
        const value = normalizeCell(row[col]);
        if (!value) continue;
        counts[col].set(value, (counts[col].get(value) || 0) + 1);
      }
    }

    const topValues = {};
    for (const col of columns) {
      const sorted = [...counts[col].entries()]
        .sort((a, b) => b[1] - a[1])
        .slice(0, topN)
        .map(([value]) => value);
      topValues[col] = new Set(sorted);
    }

    return { topValues, counts };
  }

  function buildElements(rows, topValues, counts, minEdgeWeight) {
    const nodes = new Map();
    const edges = new Map();

    for (const r of rows) {
      const present = [];
      const amt = toNumber(r[AMOUNT_COLUMN]);

      for (const col of COLUMNS) {
        const value = normalizeCell(r[col]);
        if (!value) continue;
        if (!topValues[col].has(value)) continue;

        const id = nodeId(col, value);

        if (!nodes.has(id)) {
          nodes.set(id, {
            data: {
              id,
              label: value,
              type: col,
              count: counts[col].get(value) || 0,
              amount_sum: 0
            }
          });
        }

        // sum of amount for rows where this node appears
        nodes.get(id).data.amount_sum += amt;

        present.push(id);
      }

      // Pairwise relationships within the row
      for (let i = 0; i < present.length; i++) {
        for (let j = i + 1; j < present.length; j++) {
          const a = present[i], b = present[j];
          const [source, target] = a < b ? [a, b] : [b, a];
          const key = `${source}__${target}`;

          if (!edges.has(key)) {
            edges.set(key, { data: { id: key, source, target, weight: 1, amount_sum: amt } });
          } else {
            const e = edges.get(key);
            e.data.weight += 1;
            e.data.amount_sum += amt;
          }
        }
      }
    }

    const edgeList = [...edges.values()].filter(e => e.data.weight >= minEdgeWeight);

    return {
      nodes: [...nodes.values()],
      edges: edgeList
    };
  }

  async function loadCSV(url) {
    return new Promise((resolve, reject) => {
      Papa.parse(url, {
        header: true,
        download: true,
        skipEmptyLines: true,
        complete: (res) => resolve(res.data || []),
        error: reject
      });
    });
  }

  function createCy(elements) {
    if (cy) cy.destroy();

    cy = cytoscape({
      container: document.getElementById("cy"),
      elements: [...elements.nodes, ...elements.edges],
      style: [
        {
          selector: "node",
          style: {
            "background-color": ele => TYPE_COLORS[ele.data("type")] || "#999",
            "label": "data(label)",
            "font-size": 10,
            "text-wrap": "wrap",
            "text-max-width": 90,
            "text-valign": "center",
            "text-halign": "center",
            "color": "#111",
            "text-outline-color": "#fff",
            "text-outline-width": 2,
            "width": 18,
            "height": 18
          }
        },
        {
          selector: "edge",
          style: {
            "curve-style": "bezier",
            "opacity": 0.35,
            // thickness by frequency (weight). You can switch to amount_sum if preferred.
            "width": ele => Math.min(1 + ele.data("weight"), 8),
            "line-color": "#999"
          }
        },
        { selector: ".muted", style: { "opacity": 0.12 } }
      ],
      layout: {
        name: "cose",
        animate: true,
        randomize: true,
        nodeRepulsion: 9000,
        idealEdgeLength: 90
      }
    });

    // Click node to center
    cy.on("tap", "node", (evt) => {
      const n = evt.target;
      cy.animate({ center: { eles: n }, zoom: Math.max(cy.zoom(), 1.2) }, { duration: 250 });

      // also update search summary to match clicked node
      const label = n.data("label");
      const input = document.getElementById("attrSearch");
      if (input) input.value = label;
      focusAttribute(label);
    });

    // Build label -> node ids index for search
    nodeByLabel = new Map();
    cy.nodes().forEach(n => {
      const label = n.data("label");
      if (!nodeByLabel.has(label)) nodeByLabel.set(label, []);
      nodeByLabel.get(label).push(n.id());
    });

    // Populate datalist (cap to keep DOM fast)
    const dl = document.getElementById("attrOptions");
    if (dl) {
      dl.innerHTML = "";
      let i = 0;
      for (const label of nodeByLabel.keys()) {
        const opt = document.createElement("option");
        opt.value = label;
        dl.appendChild(opt);
        i++;
        if (i >= MAX_DATALIST_OPTIONS) break;
      }
    }

    // Re-apply any active filters
    setActiveType(activeType);
    const currentSearch = document.getElementById("attrSearch")?.value?.trim();
    if (currentSearch) focusAttribute(currentSearch);

    return cy;
  }

  function validateColumns(rows) {
    const first = rows[0] || {};
    const required = [...COLUMNS, AMOUNT_COLUMN];
    const missing = required.filter(c => !(c in first));
    if (missing.length) throw new Error("Missing columns: " + missing.join(", "));
  }

  function clearSearch() {
    const input = document.getElementById("attrSearch");
    const summaryEl = document.getElementById("attrSummary");
    if (input) input.value = "";
    if (summaryEl) summaryEl.textContent = "No selection";

    // restore legend filter (or full)
    setActiveType(activeType);
  }

  function focusAttribute(label) {
    const summaryEl = document.getElementById("attrSummary");
    if (!cy || !label) {
      if (summaryEl) summaryEl.textContent = "No selection";
      return;
    }

    const ids = nodeByLabel.get(label);
    if (!ids || !ids.length) {
      if (summaryEl) summaryEl.textContent = `Not found: ${label}`;
      return;
    }

    // If the same label exists in multiple types, choose the first.
    // (If you want a chooser UI, tell me and I’ll add it.)
    const node = cy.getElementById(ids[0]);
    if (!node || node.empty()) return;

    // Dim everything, highlight neighborhood
    cy.elements().addClass("muted");
    const hood = node.closedNeighborhood();
    hood.removeClass("muted");

    // Center
    cy.animate({ center: { eles: node }, zoom: Math.max(cy.zoom(), 1.2) }, { duration: 250 });

    // Totals:
    const nodeAmt = node.data("amount_sum") || 0;

    // Sum of incident edges' amount_sum (can double-count rows if a row produces multiple edges around this node)
    let linkedAmt = 0;
    node.connectedEdges().forEach(e => linkedAmt += (e.data("amount_sum") || 0));

    const neighbors = node.neighborhood("node");
    const neighborCount = neighbors.length;

    if (summaryEl) {
      summaryEl.textContent =
        `${label} • links: ${neighborCount} • node amount: ${nodeAmt.toFixed(2)} • linked amount: ${linkedAmt.toFixed(2)}`;
    }
  }

  async function rebuildGraph() {
    if (!SHEET_CSV_URL || SHEET_CSV_URL.includes("PASTE_YOUR_PUBLISHED")) {
      setStatus("Paste your published Google Sheets CSV URL into SHEET_CSV_URL in index.html.");
      return;
    }

    try {
      setStatus("Loading CSV…");

      // Load (or reuse cached)
      const rows = cachedRows || await loadCSV(SHEET_CSV_URL);
      cachedRows = rows;

      if (!rows.length) {
        setStatus("No rows found in CSV.");
        return;
      }

      validateColumns(rows);

      const topN = Number(document.getElementById("topN").value);
      const minEdge = Number(document.getElementById("minEdge").value);

      const { topValues, counts } = computeTopValues(rows, COLUMNS, topN);
      const elements = buildElements(rows, topValues, counts, minEdge);

      document.getElementById("counts").textContent =
        `${elements.nodes.length} nodes • ${elements.edges.length} edges`;

      createCy(elements);

      setStatus(`Loaded ${rows.length} rows. Showing top ${topN}/category, edges weigh
