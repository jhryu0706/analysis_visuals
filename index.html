<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Relationship Graph</title>

  <!-- Cytoscape core -->
  <script src="https://unpkg.com/cytoscape@3.28.1/dist/cytoscape.min.js"></script>

  <!-- fcose layout -->
  <script src="https://unpkg.com/cytoscape-fcose@2.2.0/cytoscape-fcose.js"></script>

  <!-- CSV parsing -->
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #wrap { display: grid; grid-template-columns: 360px 1fr; height: 100vh; }
    #sidebar { border-right: 1px solid #ddd; padding: 14px; overflow: auto; }
    #cy { width: 100%; height: 100vh; }

    h2 { margin: 0; }
    h3 { margin: 12px 0 6px; font-size: 14px; }
    .hint { font-size: 12px; color: #666; line-height: 1.4; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }

    .row { display:flex; gap:8px; align-items:center; justify-content: space-between; }
    .pill {
      display:inline-block; padding:2px 8px; font-size:12px;
      border:1px solid #ddd; border-radius:999px; color:#444;
      white-space: nowrap;
    }

    .btnRow { display: grid; gap: 8px; margin-top: 10px; }
    button.secondary{
      padding:10px; border:1px solid #ddd; border-radius:10px;
      background:#fff; cursor:pointer; width: 100%;
    }
    button.secondary:active{ transform: translateY(1px); }

    .legend { display: grid; gap: 8px; margin-top: 8px; }
    .legend button{
      display:flex; align-items:center; gap:10px; width:100%;
      padding:10px; border:1px solid #ddd; background:#fff;
      border-radius:10px; cursor:pointer; text-align:left;
    }
    .legend button.active { outline: 3px solid #000; outline-offset: 2px; }
    .swatch { width: 14px; height: 14px; border-radius: 50%; flex: 0 0 auto; }

    .toggleRow { display:flex; align-items:center; gap:8px; margin-top: 10px; }
    input[type="checkbox"]{ transform: scale(1.1); }

    .kpi { display:grid; gap:6px; margin-top:8px; }

    hr { border: none; border-top: 1px solid #eee; margin: 14px 0; }

    .urlBox { display:grid; gap:6px; margin-top: 10px; }
    input[type="text"]{
      width:100%;
      padding:10px;
      border:1px solid #ddd;
      border-radius:10px;
      font-size: 12px;
    }
  </style>
</head>

<body>
<div id="wrap">
  <aside id="sidebar">
    <div class="row">
      <h2>Graph</h2>
      <span id="counts" class="pill">…</span>
    </div>

    <p class="hint" style="margin-top:8px;">
      Top <b>5</b> values per category (by frequency).<br>
      Click nodes to focus their neighborhood. Shift+Click to multi-select. Click background to clear.
    </p>

    <div class="btnRow">
      <button id="fitBtn" class="secondary">Fit</button>
      <button id="relayoutBtn" class="secondary">Re-layout</button>
      <button id="spreadBtn" class="secondary">Spread out</button>
      <button id="clearSelBtn" class="secondary">Clear selection</button>
      <button id="resetBtn" class="secondary">Reset filters</button>
    </div>

    <div class="toggleRow">
      <input id="edgeLabelsToggle" type="checkbox" checked />
      <label for="edgeLabelsToggle" class="hint" style="margin:0;">Show edge labels (weight + $)</label>
    </div>

    <hr>

    <h3>Legend filter</h3>
    <div class="hint">Click a type to highlight that column’s nodes.</div>
    <div class="legend" id="legend"></div>

    <hr>

    <h3>Selection info</h3>
    <div class="kpi">
      <span id="selSummary" class="pill">No selection</span>
      <div id="selDetails" class="hint"></div>
    </div>

    <hr>

    <h3>Status</h3>
    <p id="status" class="hint"></p>

    <hr>

    <h3>Data source (edit once)</h3>
    <div class="hint">
      Set <span class="mono">SHEET_CSV_URL</span> in the code below to your published CSV URL (Google Sheets → File → Share → Publish to web → CSV).
      Required headers:
      <div class="mono" style="margin-top:6px;">
        sender_name, sender_agent, sender_operator, payee_name, payee_agent, payee_operator, amount
      </div>
    </div>
  </aside>

  <main>
    <div id="cy"></div>
  </main>
</div>

<script>
  // ========= ONE PLACE TO SET YOUR URL =========
  const SHEET_CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQITmhFpwJgwfuSQFnAzUANUOB65EHTXydhXAc62IM5H-NUGhcmo-5vI9Md6-HFf2gzIYXurbqPw0tJ/pub?output=csv";
  // ===========================================

  // Register fcose layout
  cytoscape.use(cytoscapeFcose);

  // ===== Config =====
  const COLUMNS = [
    "sender_name",
    "sender_agent",
    "sender_operator",
    "payee_name",
    "payee_agent",
    "payee_operator"
  ];
  const AMOUNT_COLUMN = "amount";
  const TOP_N = 5;

  const TYPE_COLORS = {
    sender_name: "#1f77b4",
    sender_agent: "#ff7f0e",
    sender_operator: "#2ca02c",
    payee_name: "#d62728",
    payee_agent: "#9467bd",
    payee_operator: "#8c564b"
  };

  // ===== State =====
  let cy = null;
  let activeType = null;
  let selectedNodeIds = new Set();

  // ===== DOM helpers =====
  const $ = (id) => document.getElementById(id);
  function setStatus(msg) { $("status").textContent = msg || ""; }

  // ===== Data helpers =====
  function normalize(v) {
    if (v == null) return "";
    const s = String(v).trim();
    if (!s) return "";
    const low = s.toLowerCase();
    if (low === "nan" || low === "null" || low === "undefined") return "";
    return s;
  }

  function toNumber(v) {
    const n = Number(normalize(v).replace(/,/g, ""));
    return Number.isFinite(n) ? n : 0;
  }

  function fmtMoney(n) {
    const num = Number(n) || 0;
    return "$" + num.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
  }

  function nodeId(type, value) {
    return `${type}::${String(value)}`;
  }

  // ===== CSV load (robust header trimming + BOM removal) =====
  async function loadCSV(url) {
    return new Promise((resolve, reject) => {
      Papa.parse(url, {
        header: true,
        download: true,
        skipEmptyLines: true,
        transformHeader: (h) =>
          (h ?? "")
            .toString()
            .replace(/^\uFEFF/, "")  // remove BOM if present
            .trim(),
        complete: (res) => resolve(res.data || []),
        error: reject
      });
    });
  }

  function validateHeaders(rows) {
    const first = rows[0] || {};
    const keys = Object.keys(first)
      .map(k => (k ?? "").toString().replace(/^\uFEFF/, "").trim())
      .filter(k => k.length > 0);

    const required = [...COLUMNS, AMOUNT_COLUMN];
    const missing = required.filter(h => !keys.includes(h));
    if (missing.length) {
      throw new Error(
        "Missing columns: " + missing.join(", ") +
        "\nFound columns: " + keys.join(", ")
      );
    }
  }

  // ===== Legend =====
  function initLegend() {
    const el = $("legend");
    el.innerHTML = "";

    for (const type of COLUMNS) {
      const btn = document.createElement("button");
      btn.dataset.type = type;

      const sw = document.createElement("span");
      sw.className = "swatch";
      sw.style.background = TYPE_COLORS[type] || "#999";

      const label = document.createElement("span");
      label.textContent = type;

      btn.append(sw, label);
      btn.addEventListener("click", () => toggleType(type));
      el.appendChild(btn);
    }
  }

  function toggleType(type) {
    activeType = (activeType === type ? null : type);
    document.querySelectorAll("#legend button").forEach(b => {
      b.classList.toggle("active", b.dataset.type === activeType);
    });
    applyFocusStyles();
    updateSelectionPanel();
  }

  // ===== Build graph =====
  function computeTopValues(rows) {
    const counts = {};
    for (const c of COLUMNS) counts[c] = new Map();

    for (const r of rows) {
      for (const c of COLUMNS) {
        const v = normalize(r[c]);
        if (!v) continue;
        counts[c].set(v, (counts[c].get(v) || 0) + 1);
      }
    }

    const top = {};
    for (const c of COLUMNS) {
      top[c] = new Set(
        [...counts[c].entries()]
          .sort((a,b) => b[1] - a[1])
          .slice(0, TOP_N)
          .map(([val]) => val)
      );
    }
    return { top, counts };
  }

  function buildElements(rows, top, counts) {
    const nodes = new Map();
    const edges = new Map();

    for (const r of rows) {
      const amt = toNumber(r[AMOUNT_COLUMN]);
      const present = [];

      for (const c of COLUMNS) {
        const v = normalize(r[c]);
        if (!v || !top[c].has(v)) continue;

        const id = nodeId(c, v);
        if (!nodes.has(id)) {
          nodes.set(id, {
            data: {
              id,
              label: v,
              type: c,
              count: counts[c].get(v) || 0,
              amount_sum: 0
            }
          });
        }
        nodes.get(id).data.amount_sum += amt;
        present.push(id);
      }

      // pairwise edges within row
      for (let i=0; i<present.length; i++) {
        for (let j=i+1; j<present.length; j++) {
          const a = present[i], b = present[j];
          const [s,t] = (a < b) ? [a,b] : [b,a];
          const key = `${s}__${t}`;
          if (!edges.has(key)) {
            edges.set(key, { data: { id:key, source:s, target:t, weight:0, amount_sum:0, label:"" } });
          }
          const e = edges.get(key).data;
          e.weight += 1;
          e.amount_sum += amt;
        }
      }
    }

    // Add readable labels
    for (const e of edges.values()) {
      e.data.label = `w=${e.data.weight}  $=${fmtMoney(e.data.amount_sum)}`;
    }

    return { nodes: [...nodes.values()], edges: [...edges.values()] };
  }

  // ===== Layout config =====
  function fcoseLayout({ spread }) {
    return {
      name: "fcose",
      animate: true,
      animationDuration: 900,
      fit: true,
      padding: 60,
      nodeSeparation: spread ? 140 : 90,
      idealEdgeLength: spread ? 220 : 140,
      nodeRepulsion: spread ? 18000 : 12000,
      gravity: 0.18,
      packComponents: true,
      quality: "default",
      numIter: spread ? 2400 : 1600
    };
  }

  function runRelayout(spread) {
    if (!cy) return;
    cy.stop();
    cy.nodes().unlock();
    cy.layout(fcoseLayout({ spread })).run();
  }

  // ===== Render =====
  function createCy(elements) {
    if (cy) cy.destroy();

    cy = cytoscape({
      container: $("cy"),
      elements: [...elements.nodes, ...elements.edges],
      boxSelectionEnabled: true,
      selectionType: "additive",
      style: [
        {
          selector: "node",
          style: {
            "background-color": ele => TYPE_COLORS[ele.data("type")] || "#999",
            "label": "data(label)",
            "font-size": 10,
            "text-wrap": "wrap",
            "text-max-width": 110,
            "text-valign": "center",
            "text-halign": "center",
            "color": "#111",
            "text-outline-color": "#fff",
            "text-outline-width": 2,
            "width": 22,
            "height": 22
          }
        },
        {
          selector: "node.selected",
          style: {
            "border-width": 3,
            "border-color": "#111",
            "width": 26,
            "height": 26
          }
        },
        {
          selector: "edge",
          style: {
            "curve-style": "bezier",
            "opacity": 0.40,
            "line-color": "#999",
            "width": ele => Math.min(1 + ele.data("weight"), 8),
            "label": "data(label)",
            "font-size": 9,
            "color": "#111",
            "text-rotation": "autorotate",
            "text-margin-y": -8,
            "text-background-color": "#fff",
            "text-background-opacity": 0.85,
            "text-background-padding": 2
          }
        },
        { selector: ".muted", style: { "opacity": 0.10 } },
        { selector: ".hideEdgeLabels", style: { "label": "" } }
      ],
      layout: fcoseLayout({ spread: false })
    });

    // Background click clears selection
    cy.on("tap", (evt) => {
      if (evt.target === cy) clearSelection();
    });

    // Node click selection (Shift+Click toggles)
    cy.on("tap", "node", (evt) => {
      const n = evt.target;
      const isShift = evt.originalEvent && evt.originalEvent.shiftKey;

      if (!isShift) {
        selectedNodeIds.clear();
        selectedNodeIds.add(n.id());
      } else {
        if (selectedNodeIds.has(n.id())) selectedNodeIds.delete(n.id());
        else selectedNodeIds.add(n.id());
      }

      applyFocusStyles();
      updateSelectionPanel();
      cy.animate({ center: { eles: n }, zoom: Math.max(cy.zoom(), 1.15) }, { duration: 200 });
    });

    // Box selection -> convert to our set
    cy.on("boxend", () => {
      const sels = cy.nodes(":selected");
      if (!sels.length) return;
      selectedNodeIds.clear();
      sels.forEach(n => selectedNodeIds.add(n.id()));
      cy.nodes().unselect();
      applyFocusStyles();
      updateSelectionPanel();
    });

    // Edge label toggle
    $("edgeLabelsToggle").addEventListener("change", () => {
      if (!cy) return;
      cy.edges().toggleClass("hideEdgeLabels", !$("edgeLabelsToggle").checked);
    });
    cy.edges().toggleClass("hideEdgeLabels", !$("edgeLabelsToggle").checked);

    // Initial panel
    updateSelectionPanel();
    return cy;
  }

  // ===== Focus / muting =====
  function applyFocusStyles() {
    if (!cy) return;

    cy.elements().removeClass("muted");
    cy.nodes().removeClass("selected");

    const hasSelection = selectedNodeIds.size > 0;
    const hasType = !!activeType;

    if (!hasSelection && !hasType) return;

    cy.elements().addClass("muted");
    let keep = cy.collection();

    if (hasSelection) {
      for (const id of selectedNodeIds) {
        const n = cy.getElementById(id);
        if (n && !n.empty()) keep = keep.union(n.closedNeighborhood());
      }
      for (const id of selectedNodeIds) {
        const n = cy.getElementById(id);
        if (n && !n.empty()) n.removeClass("muted").addClass("selected");
      }
    } else if (hasType) {
      const typeNodes = cy.nodes().filter(n => n.data("type") === activeType);
      keep = keep.union(typeNodes).union(typeNodes.connectedEdges()).union(typeNodes.neighborhood("node"));
    }

    keep.removeClass("muted");
  }

  function clearSelection() {
    selectedNodeIds.clear();
    if (!cy) return;
    cy.nodes().removeClass("selected");
    applyFocusStyles();
    updateSelectionPanel();
  }

  function resetAll() {
    activeType = null;
    document.querySelectorAll("#legend button").forEach(b => b.classList.remove("active"));
    clearSelection();
    if (cy) cy.elements().removeClass("muted");
    updateSelectionPanel();
  }

  // ===== Selection panel =====
  function updateSelectionPanel() {
    const summary = $("selSummary");
    const details = $("selDetails");

    if (!cy || selectedNodeIds.size === 0) {
      summary.textContent = activeType ? `Type filter: ${activeType}` : "No selection";
      details.textContent = activeType
        ? "Click nodes to focus their connections (Shift+Click for multi-select)."
        : "Click a node to see its neighborhood and totals.";
      return;
    }

    const nodes = [...selectedNodeIds]
      .map(id => cy.getElementById(id))
      .filter(n => n && !n.empty());

    const hood = nodes.reduce((acc, n) => acc.union(n.closedNeighborhood()), cy.collection());
    const hoodNodes = hood.nodes();
    const hoodEdges = hood.edges();

    let edgeAmount = 0;
    let edgeWeight = 0;
    hoodEdges.forEach(e => {
      edgeAmount += (e.data("amount_sum") || 0);
      edgeWeight += (e.data("weight") || 0);
    });

    summary.textContent = `${nodes.length} selected • neighborhood: ${hoodNodes.length} nodes, ${hoodEdges.length} edges`;

    const related = hoodNodes
      .filter(n => !selectedNodeIds.has(n.id()))
      .map(n => `${n.data("label")} (${n.data("type")})`)
      .slice(0, 12);

    details.innerHTML = `
      <div><b>Edge totals:</b> w=${edgeWeight} • $=${fmtMoney(edgeAmount)}</div>
      <div style="margin-top:6px;"><b>Related:</b> ${related.length ? related.join(", ") : "—"}${(hoodNodes.length - nodes.length) > 12 ? " …" : ""}</div>
    `;
  }

  // ===== Main =====
  async function main() {
    initLegend();

    $("fitBtn").addEventListener("click", () => cy && cy.fit(undefined, 40));
    $("relayoutBtn").addEventListener("click", () => runRelayout(false));
    $("spreadBtn").addEventListener("click", () => runRelayout(true));
    $("clearSelBtn").addEventListener("click", clearSelection);
    $("resetBtn").addEventListener("click", resetAll);

    if (!SHEET_CSV_URL)
    {
      setStatus("Set SHEET_CSV_URL in the code (top of <script>) to your published CSV URL.");
      return;
    }

    try {
      setStatus("Loading CSV…");
      const rows = await loadCSV(SHEET_CSV_URL);

      if (!rows.length) {
        setStatus("No rows found in CSV.");
        return;
      }

      validateHeaders(rows);

      setStatus("Computing top values & building graph…");
      const { top, counts } = computeTopValues(rows);
      const elements = buildElements(rows, top, counts);

      $("counts").textContent = `${elements.nodes.length} nodes • ${elements.edges.length} edges`;

      setStatus("Rendering…");
      createCy(elements);

      setStatus(`Loaded ${rows.length} rows • top ${TOP_N}/category • click nodes to explore`);
    } catch (e) {
      console.error(e);
      setStatus("Error: " + (e?.message || String(e)));
      alert(e?.message || String(e));
    }
  }

  main();
</script>
</body>
</html>
