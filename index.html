<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Relationship Graph</title>

  <!-- Cytoscape core -->
  <script src="https://unpkg.com/cytoscape@3.28.1/dist/cytoscape.min.js"></script>

  <!-- fcose layout -->
  <script src="https://unpkg.com/cytoscape-fcose@2.2.0/cytoscape-fcose.js"></script>

  <!-- CSV parsing -->
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #wrap { display: grid; grid-template-columns: 380px 1fr; height: 100vh; }
    #sidebar { border-right: 1px solid #ddd; padding: 14px; overflow: auto; }
    #cy { width: 100%; height: 100vh; }

    h2 { margin: 0; }
    h3 { margin: 12px 0 6px; font-size: 14px; }
    .hint { font-size: 12px; color: #666; line-height: 1.4; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }

    .row { display:flex; gap:8px; align-items:center; justify-content: space-between; }
    .pill {
      display:inline-block; padding:2px 8px; font-size:12px;
      border:1px solid #ddd; border-radius:999px; color:#444; white-space: nowrap;
    }

    .btnRow { display: grid; gap: 8px; margin-top: 10px; }
    button.secondary{
      padding:10px; border:1px solid #ddd; border-radius:10px;
      background:#fff; cursor:pointer; width: 100%;
    }

    .legend { display: grid; gap: 8px; margin-top: 8px; }
    .legend button{
      display:flex; align-items:center; gap:10px; width:100%;
      padding:10px; border:1px solid #ddd; background:#fff;
      border-radius:10px; cursor:pointer; text-align:left;
    }
    .legend button.active { outline: 3px solid #000; outline-offset: 2px; }
    .swatch { width: 14px; height: 14px; border-radius: 50%; flex: 0 0 auto; }

    .toggleRow { display:flex; align-items:center; gap:8px; margin-top: 10px; }
    input[type="checkbox"]{ transform: scale(1.1); }

    hr { border: none; border-top: 1px solid #eee; margin: 14px 0; }

    .panel {
      border: 1px solid #eee;
      border-radius: 10px;
      padding: 10px;
      background: #fff;
      margin-top: 10px;
      display: grid;
      gap: 8px;
    }
    .kv { display:flex; gap:8px; align-items:flex-start; justify-content: space-between; }
    .kv .k { font-size: 12px; color:#666; }
    .kv .v { font-size: 12px; color:#111; text-align:right; overflow-wrap:anywhere; }

    .ok { color: #166534; font-weight: 700; }
    .bad { color: #991b1b; font-weight: 700; }

    .errorBox {
      margin-top: 10px;
      padding: 10px;
      border: 1px solid #f3c2c2;
      background: #fff5f5;
      border-radius: 10px;
      display: none;
    }
    .errorTitle { font-weight: 700; font-size: 12px; margin-bottom: 6px; }
    .errorText { font-size: 12px; color: #7a1f1f; white-space: pre-wrap; }

    .small { font-size: 11px; color:#666; }
  </style>
</head>

<body>
<div id="wrap">
  <aside id="sidebar">
    <div class="row">
      <h2>Graph</h2>
      <span id="counts" class="pill">…</span>
    </div>

    <p class="hint" style="margin-top:8px;">
      Top <b>5</b> values per category (by frequency). Click nodes to focus their neighborhood.
      Shift+Click to multi-select. Click background to clear.
    </p>

    <div class="btnRow">
      <button id="fitBtn" class="secondary">Fit</button>
      <button id="relayoutBtn" class="secondary">Re-layout</button>
      <button id="spreadBtn" class="secondary">Spread out</button>
      <button id="clearSelBtn" class="secondary">Clear selection</button>
      <button id="resetBtn" class="secondary">Reset filters</button>
    </div>

    <div class="toggleRow">
      <input id="edgeLabelsToggle" type="checkbox" checked />
      <label for="edgeLabelsToggle" class="hint" style="margin:0;">Show edge labels (weight + $)</label>
    </div>

    <div class="panel">
      <div class="kv">
        <div class="k">Connection</div>
        <div class="v" id="connStatus">…</div>
      </div>
      <div class="kv">
        <div class="k">HTTP</div>
        <div class="v" id="httpStatus">…</div>
      </div>
      <div class="kv">
        <div class="k">Detected headers</div>
        <div class="v mono" id="headerList">…</div>
      </div>
      <div class="small">
        Tip: open your CSV URL in a new tab — you should see/download raw CSV.
      </div>
    </div>

    <div id="errorBox" class="errorBox">
      <div class="errorTitle">Problem</div>
      <div class="errorText" id="errorText"></div>
    </div>

    <hr>

    <h3>Legend filter</h3>
    <div class="hint">Click a type to highlight that column’s nodes.</div>
    <div class="legend" id="legend"></div>

    <hr>

    <h3>Status</h3>
    <p id="status" class="hint"></p>

    <hr>

    <h3>Data requirements</h3>
    <div class="hint">
      Required headers:
      <div class="mono" style="margin-top:6px;">
        sender_name, sender_agent, sender_operator, payee_name, payee_agent, payee_operator, amount
      </div>
    </div>
  </aside>

  <main>
    <div id="cy"></div>
  </main>
</div>

<script>
  // ========= ONE PLACE TO SET YOUR URL =========
  const SHEET_CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQITmhFpwJgwfuSQFnAzUANUOB65EHTXydhXAc62IM5H-NUGhcmo-5vI9Md6-HFf2gzIYXurbqPw0tJ/pub?output=csv";
  // ===========================================

  cytoscape.use(cytoscapeFcose);

  // ===== Config =====
  const COLUMNS = [
    "sender_name",
    "sender_agent",
    "sender_operator",
    "payee_name",
    "payee_agent",
    "payee_operator"
  ];
  const AMOUNT_COLUMN = "amount";
  const TOP_N = 5;

  const TYPE_COLORS = {
    sender_name: "#1f77b4",
    sender_agent: "#ff7f0e",
    sender_operator: "#2ca02c",
    payee_name: "#d62728",
    payee_agent: "#9467bd",
    payee_operator: "#8c564b"
  };

  // ===== State =====
  let cy = null;
  let activeType = null;
  let selectedNodeIds = new Set();

  // ===== DOM =====
  const $ = (id) => document.getElementById(id);
  function setStatus(msg) { $("status").textContent = msg || ""; }

  function showError(text) {
    $("errorBox").style.display = "block";
    $("errorText").textContent = text || "";
  }
  function clearError() {
    $("errorBox").style.display = "none";
    $("errorText").textContent = "";
  }

  function setConn(ok, msg) {
    $("connStatus").innerHTML = ok
      ? `<span class="ok">Connected</span> — ${escapeHtml(msg || "")}`
      : `<span class="bad">Failed</span> — ${escapeHtml(msg || "")}`;
  }
  function setHttp(msg) { $("httpStatus").textContent = msg || "—"; }
  function setHeaders(list) { $("headerList").textContent = (list && list.length) ? list.join(", ") : "—"; }

  function escapeHtml(s) {
    return String(s || "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;");
  }

  // ===== Helpers =====
  function normalize(v) {
    if (v == null) return "";
    const s = String(v).trim();
    if (!s) return "";
    const low = s.toLowerCase();
    if (low === "nan" || low === "null" || low === "undefined") return "";
    return s;
  }

  function toNumber(v) {
    const n = Number(normalize(v).replace(/,/g, ""));
    return Number.isFinite(n) ? n : 0;
  }

  function fmtMoney(n) {
    const num = Number(n) || 0;
    return "$" + num.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
  }

  function nodeId(type, value) {
    return `${type}::${String(value)}`;
  }

  function normalizeHeader(h) {
    return (h ?? "").toString().replace(/^\uFEFF/, "").trim();
  }

  // ===== Connection + header check (fetch + parse only header row) =====
  async function connectAndInspect(url) {
    clearError();
    setConn(false, "Connecting…");
    setHttp("…");
    setHeaders([]);

    let resp;
    try {
      resp = await fetch(url, { cache: "no-store" });
    } catch (e) {
      setConn(false, "Network/CORS blocked");
      setHttp("fetch() failed");
      throw new Error(
        "Could not fetch the CSV URL.\n\n" +
        "Common causes:\n" +
        "• You opened index.html via file:// (double click). Use GitHub Pages or a local server.\n" +
        "• The sheet is not published/public.\n" +
        "• CORS blocked the request.\n\n" +
        "Raw error: " + (e?.message || String(e))
      );
    }

    setHttp(`${resp.status} ${resp.statusText}`);

    if (!resp.ok) {
      setConn(false, "HTTP error");
      throw new Error(`HTTP error fetching CSV: ${resp.status} ${resp.statusText}`);
    }

    const text = await resp.text();

    // Parse just enough to get headers + a first row
    const parsed = Papa.parse(text, {
      header: true,
      skipEmptyLines: true,
      transformHeader: normalizeHeader
    });

    if (parsed.errors && parsed.errors.length) {
      setConn(false, "Parse error");
      throw new Error("CSV parse error: " + parsed.errors[0].message);
    }

    const first = parsed.data?.[0] || {};
    const headers = Object.keys(first)
      .map(normalizeHeader)
      .filter(k => k.length > 0);

    setHeaders(headers);

    // Mark connection as OK as soon as we successfully fetched + parsed
    setConn(true, "Fetched & parsed CSV");

    return { rows: parsed.data || [], headers };
  }

  function validateHeadersFromList(headers) {
    const required = [...COLUMNS, AMOUNT_COLUMN];
    const missing = required.filter(h => !headers.includes(h));
    if (missing.length) {
      throw new Error(
        "Missing required columns:\n" + missing.join(", ") + "\n\n" +
        "Found columns:\n" + headers.join(", ")
      );
    }
  }

  // ===== Legend =====
  function initLegend() {
    const el = $("legend");
    el.innerHTML = "";
    for (const type of COLUMNS) {
      const btn = document.createElement("button");
      btn.dataset.type = type;

      const sw = document.createElement("span");
      sw.className = "swatch";
      sw.style.background = TYPE_COLORS[type] || "#999";

      const label = document.createElement("span");
      label.textContent = type;

      btn.append(sw, label);
      btn.addEventListener("click", () => toggleType(type));
      el.appendChild(btn);
    }
  }

  function toggleType(type) {
    activeType = (activeType === type ? null : type);
    document.querySelectorAll("#legend button").forEach(b => {
      b.classList.toggle("active", b.dataset.type === activeType);
    });
    applyFocusStyles();
  }

  // ===== Build graph =====
  function computeTopValues(rows) {
    const counts = {};
    for (const c of COLUMNS) counts[c] = new Map();

    for (const r of rows) {
      for (const c of COLUMNS) {
        const v = normalize(r[c]);
        if (!v) continue;
        counts[c].set(v, (counts[c].get(v) || 0) + 1);
      }
    }

    const top = {};
    for (const c of COLUMNS) {
      top[c] = new Set(
        [...counts[c].entries()]
          .sort((a,b) => b[1] - a[1])
          .slice(0, TOP_N)
          .map(([val]) => val)
      );
    }
    return { top, counts };
  }

  function buildElements(rows, top, counts) {
    const nodes = new Map();
    const edges = new Map();

    for (const r of rows) {
      const amt = toNumber(r[AMOUNT_COLUMN]);
      const present = [];

      for (const c of COLUMNS) {
        const v = normalize(r[c]);
        if (!v || !top[c].has(v)) continue;

        const id = nodeId(c, v);
        if (!nodes.has(id)) {
          nodes.set(id, { data: { id, label: v, type: c, count: counts[c].get(v) || 0, amount_sum: 0 } });
        }
        nodes.get(id).data.amount_sum += amt;
        present.push(id);
      }

      for (let i=0; i<present.length; i++) {
        for (let j=i+1; j<present.length; j++) {
          const a = present[i], b = present[j];
          const [s,t] = (a < b) ? [a,b] : [b,a];
          const key = `${s}__${t}`;
          if (!edges.has(key)) {
            edges.set(key, { data: { id:key, source:s, target:t, weight:0, amount_sum:0, label:"" } });
          }
          const e = edges.get(key).data;
          e.weight += 1;
          e.amount_sum += amt;
        }
      }
    }

    for (const e of edges.values()) {
      e.data.label = `w=${e.data.weight}  $=${fmtMoney(e.data.amount_sum)}`;
    }

    return { nodes: [...nodes.values()], edges: [...edges.values()] };
  }

  // ===== Layout =====
  function fcoseLayout({ spread }) {
    return {
      name: "fcose",
      animate: true,
      animationDuration: 900,
      fit: true,
      padding: 60,
      nodeSeparation: spread ? 140 : 90,
      idealEdgeLength: spread ? 220 : 140,
      nodeRepulsion: spread ? 18000 : 12000,
      gravity: 0.18,
      packComponents: true,
      quality: "default",
      numIter: spread ? 2400 : 1600
    };
  }

  function runRelayout(spread) {
    if (!cy) return;
    cy.stop();
    cy.nodes().unlock();
    cy.layout(fcoseLayout({ spread })).run();
  }

  // ===== Render =====
  function createCy(elements) {
    if (cy) cy.destroy();

    cy = cytoscape({
      container: $("cy"),
      elements: [...elements.nodes, ...elements.edges],
      boxSelectionEnabled: true,
      selectionType: "additive",
      style: [
        {
          selector: "node",
          style: {
            "background-color": ele => TYPE_COLORS[ele.data("type")] || "#999",
            "label": "data(label)",
            "font-size": 10,
            "text-wrap": "wrap",
            "text-max-width": 110,
            "text-valign": "center",
            "text-halign": "center",
            "color": "#111",
            "text-outline-color": "#fff",
            "text-outline-width": 2,
            "width": 22,
            "height": 22
          }
        },
        {
          selector: "edge",
          style: {
            "curve-style": "bezier",
            "opacity": 0.40,
            "line-color": "#999",
            "width": ele => Math.min(1 + ele.data("weight"), 8),
            "label": "data(label)",
            "font-size": 9,
            "color": "#111",
            "text-rotation": "autorotate",
            "text-margin-y": -8,
            "text-background-color": "#fff",
            "text-background-opacity": 0.85,
            "text-background-padding": 2
          }
        },
        { selector: ".muted", style: { "opacity": 0.10 } },
        { selector: ".hideEdgeLabels", style: { "label": "" } }
      ],
      layout: fcoseLayout({ spread: false })
    });

    cy.on("tap", (evt) => {
      if (evt.target === cy) {
        selectedNodeIds.clear();
        applyFocusStyles();
      }
    });

    cy.on("tap", "node", (evt) => {
      const n = evt.target;
      const isShift = evt.originalEvent && evt.originalEvent.shiftKey;

      if (!isShift) {
        selectedNodeIds.clear();
        selectedNodeIds.add(n.id());
      } else {
        if (selectedNodeIds.has(n.id())) selectedNodeIds.delete(n.id());
        else selectedNodeIds.add(n.id());
      }

      applyFocusStyles();
      cy.animate({ center: { eles: n }, zoom: Math.max(cy.zoom(), 1.15) }, { duration: 200 });
    });

    $("edgeLabelsToggle").addEventListener("change", () => {
      if (!cy) return;
      cy.edges().toggleClass("hideEdgeLabels", !$("edgeLabelsToggle").checked);
    });
    cy.edges().toggleClass("hideEdgeLabels", !$("edgeLabelsToggle").checked);

    return cy;
  }

  function applyFocusStyles() {
    if (!cy) return;
    cy.elements().removeClass("muted");

    const hasSelection = selectedNodeIds.size > 0;
    const hasType = !!activeType;
    if (!hasSelection && !hasType) return;

    cy.elements().addClass("muted");
    let keep = cy.collection();

    if (hasSelection) {
      for (const id of selectedNodeIds) {
        const n = cy.getElementById(id);
        if (n && !n.empty()) keep = keep.union(n.closedNeighborhood());
      }
    } else if (hasType) {
      const typeNodes = cy.nodes().filter(n => n.data("type") === activeType);
      keep = keep.union(typeNodes).union(typeNodes.connectedEdges()).union(typeNodes.neighborhood("node"));
    }

    keep.removeClass("muted");
  }

  // ===== Main =====
  async function main() {
    initLegend();

    $("fitBtn").addEventListener("click", () => cy && cy.fit(undefined, 40));
    $("relayoutBtn").addEventListener("click", () => runRelayout(false));
    $("spreadBtn").addEventListener("click", () => runRelayout(true));
    $("clearSelBtn").addEventListener("click", () => { selectedNodeIds.clear(); applyFocusStyles(); });
    $("resetBtn").addEventListener("click", () => { activeType = null; selectedNodeIds.clear(); applyFocusStyles(); });

    try {
      setStatus("Connecting + inspecting headers…");
      const { rows, headers } = await connectAndInspect(SHEET_CSV_URL);

      // Validate headers and show a nice error if wrong
      validateHeadersFromList(headers);

      setStatus("Building graph…");
      const { top, counts } = computeTopValues(rows);
      const elements = buildElements(rows, top, counts);
      $("counts").textContent = `${elements.nodes.length} nodes • ${elements.edges.length} edges`;

      setStatus("Rendering…");
      createCy(elements);

      setStatus(`Loaded ${rows.length} rows • top ${TOP_N}/category`);
    } catch (e) {
      console.error(e);
      showError(e?.message || String(e));
      setStatus("Failed. See error box.");
    }
  }

  main();
</script>
</body>
</html>
